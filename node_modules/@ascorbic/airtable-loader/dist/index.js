// src/airtable-loader.ts
import { AstroError } from "astro/errors";
import Airtable from "airtable";

// src/schema.ts
import { z } from "astro/zod";
import { match, P } from "ts-pattern";
var STRING_TYPES = /* @__PURE__ */ new Set([
  "string",
  "singleLineText",
  "multilineText",
  "richText",
  "phoneNumber",
  "barcode"
]);
var NUMBER_TYPES = /* @__PURE__ */ new Set([
  "number",
  "percent",
  "currency",
  "rating",
  "count",
  "autoNumber"
]);
var DATE_TYPES = /* @__PURE__ */ new Set([
  "date",
  "dateTime",
  "createdTime",
  "lastModifiedTime"
]);
var USER_TYPES = /* @__PURE__ */ new Set([
  "singleCollaborator",
  "createdBy",
  "lastModifiedBy"
]);
var BOOLEAN_TYPES = /* @__PURE__ */ new Set(["checkbox", "boolean"]);
var userSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string()
});
var attachmentSchema = z.object({
  id: z.string(),
  url: z.string().url(),
  filename: z.string(),
  size: z.number().optional(),
  type: z.string().optional()
});
var airtableTypeToZodType = (field) => {
  return match(field).with({ type: P.when((t) => STRING_TYPES.has(t)) }, () => z.string()).with({ type: P.when((t) => NUMBER_TYPES.has(t)) }, () => z.number()).with({ type: P.when((t) => DATE_TYPES.has(t)) }, () => z.coerce.date()).with({ type: P.when((t) => USER_TYPES.has(t)) }, () => userSchema).with({ type: P.when((t) => BOOLEAN_TYPES.has(t)) }, () => z.boolean()).with({ type: "email" }, () => z.string().email()).with({ type: "url" }, () => z.string().url()).with(
    { type: "singleSelect", options: { choices: P.array(P.any) } },
    ({ options }) => {
      const choices = options.choices.map(({ name }) => name);
      return z.enum(choices);
    }
  ).with(
    { type: "multipleSelects", options: { choices: P.array(P.any) } },
    ({ options }) => {
      const choices = options.choices.map(({ name }) => name);
      return z.array(z.enum(choices));
    }
  ).with({ type: "multipleAttachments" }, () => z.array(attachmentSchema)).with({ type: "multipleCollaborators" }, () => z.array(userSchema)).with(
    { type: "button" },
    () => z.object({
      label: z.string(),
      url: z.string().url().optional()
    })
  ).with(
    { type: "formula", options: { result: { type: P.string } } },
    ({ options }) => {
      const resultType = options.result.type;
      if (resultType === "number") {
        return z.number();
      } else if (resultType === "string") {
        return z.string();
      }
      return z.unknown();
    }
  ).with(
    {
      type: "multipleLookupValues",
      options: { result: { type: P.when((t) => STRING_TYPES.has(t)) } }
    },
    () => z.array(z.string())
  ).with(
    {
      type: "multipleLookupValues",
      options: { result: { type: P.when((t) => NUMBER_TYPES.has(t)) } }
    },
    () => z.array(z.number())
  ).with(
    {
      type: "multipleLookupValues",
      options: { result: { type: P.when((t) => BOOLEAN_TYPES.has(t)) } }
    },
    () => z.array(z.boolean())
  ).with(
    { type: "multipleLookupValues", options: { result: { type: "array" } } },
    () => z.array(z.array(z.unknown()))
  ).with(
    { type: "multipleLookupValues", options: { result: { type: "object" } } },
    () => z.array(z.object({}).passthrough())
  ).with({ type: "duration" }, () => z.number()).otherwise(() => z.unknown());
};
var zodSchemaFromAirtableTable = async ({
  baseID,
  tableIdOrName,
  apiKey
}) => {
  const schemaUrl = `https://api.airtable.com/v0/meta/bases/${baseID}/tables`;
  const res = await fetch(schemaUrl, {
    headers: {
      Authorization: `Bearer ${apiKey}`
    }
  });
  if (!res.ok) {
    throw new Error(`Failed to fetch Airtable schema: ${res.statusText}`);
  }
  const response = await res.json();
  const tableSchema = response.tables.find(
    (table) => table.name === tableIdOrName || table.id === tableIdOrName
  );
  if (!tableSchema) {
    throw new Error(`Table ${tableIdOrName} not found in base schema.`);
  }
  const schemaObject = {};
  for (const field of tableSchema.fields) {
    const zodType = airtableTypeToZodType(field).optional();
    schemaObject[field.name] = zodType;
  }
  return z.object(schemaObject);
};

// src/airtable-loader.ts
function airtableLoader({
  token = import.meta.env.AIRTABLE_TOKEN,
  base,
  table,
  queryParams
}) {
  if (!token) {
    throw new AstroError(
      "Missing Airtable token. Set it in the AIRTABLE_TOKEN environment variable or pass it as an option."
    );
  }
  const baseInstance = new Airtable({ apiKey: token }).base(base);
  return {
    name: "airtable-loader",
    load: async ({ logger, parseData, store }) => {
      logger.info(`Loading data from table "${table}"`);
      const records = await baseInstance(table).select(queryParams).all();
      for (const { id, fields } of records) {
        const data = await parseData({ id, data: fields });
        store.set({ id, data });
      }
      logger.info(`Loaded ${records.length} records from "${table}"`);
    },
    schema: () => zodSchemaFromAirtableTable({
      baseID: base,
      tableIdOrName: table,
      apiKey: token
    })
  };
}
export {
  airtableLoader
};
