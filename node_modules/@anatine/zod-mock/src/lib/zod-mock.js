"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodMockError = exports.generateMock = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const faker_1 = require("@faker-js/faker");
const randExp = require("randexp");
const zod_1 = require("zod");
const zod_mockery_map_1 = require("./zod-mockery-map");
function parseObject(zodRef, options) {
    return Object.keys(zodRef.shape).reduce((carry, key) => (Object.assign(Object.assign({}, carry), { [key]: generateMock(zodRef.shape[key], Object.assign(Object.assign({}, options), { keyName: key })) })), {});
}
function parseRecord(zodRef, options) {
    const recordKeysLength = (options === null || options === void 0 ? void 0 : options.recordKeysLength) || 1;
    return new Array(recordKeysLength).fill(null).reduce((prev) => {
        return Object.assign(Object.assign({}, prev), { [generateMock(zodRef.keySchema, options)]: generateMock(zodRef.valueSchema, options) });
    }, {});
}
function findMatchingFaker(keyName, fakerOption, mockeryMapper = zod_mockery_map_1.mockeryMapper) {
    const fakerInstance = fakerOption || faker_1.faker;
    const lowerCaseKeyName = keyName.toLowerCase();
    const withoutDashesUnderscores = lowerCaseKeyName.replace(/_|-/g, '');
    let fnName = undefined;
    // Well, all the dep warnings are going to require mapping
    const mapped = mockeryMapper(keyName, fakerInstance);
    if (mapped)
        return mapped;
    const sectionName = Object.keys(fakerInstance).find((sectionKey) => {
        return Object.keys(fakerInstance[sectionKey] || {}).find((fnKey) => {
            var _a;
            const lower = fnKey.toLowerCase();
            fnName =
                lower === lowerCaseKeyName || lower === withoutDashesUnderscores
                    ? keyName
                    : undefined;
            // Skipping depreciated items
            // const depreciated: Record<string, string[]> = {
            //   random: ['image', 'number', 'float', 'uuid', 'boolean', 'hexaDecimal'],
            // };
            // if (
            //   Object.keys(depreciated).find((key) =>
            //     key === sectionKey
            //       ? depreciated[key].find((fn) => fn === fnName)
            //       : false
            //   )
            // ) {
            //   return undefined;
            // }
            if (fnName) {
                // TODO: it would be good to clean up these type castings
                const fn = (_a = fakerInstance[sectionKey]) === null || _a === void 0 ? void 0 : _a[fnName];
                if (typeof fn === 'function') {
                    try {
                        // some Faker functions, such as `faker.mersenne.seed`, are known to throw errors if called
                        // with incorrect parameters
                        const mock = fn();
                        return typeof mock === 'string' ||
                            typeof mock === 'number' ||
                            typeof mock === 'boolean' ||
                            mock instanceof Date
                            ? fnName
                            : undefined;
                    }
                    catch (_error) {
                        // do nothing. undefined will be returned eventually.
                    }
                }
            }
            return undefined;
        });
    });
    if (sectionName && fnName) {
        const section = fakerInstance[sectionName];
        return section ? section[fnName] : undefined;
    }
}
/**
 * Generate mock value from a matching faker function extracted from the mockeryMapper
 * @param options mock generator options
 * @returns a mock value if a faker function is found in the mockeryMapper passed
 */
function generateMockFromMatchingFaker(options) {
    var _a;
    // check if there exists a faker for the given key in the mockery mapper
    const foundMockeryMapperFaker = (options === null || options === void 0 ? void 0 : options.keyName)
        ? findMatchingFaker(options === null || options === void 0 ? void 0 : options.keyName, options.faker, options.mockeryMapper)
        : undefined;
    // generate the mock value from the faker function found
    return (_a = foundMockeryMapperFaker === null || foundMockeryMapperFaker === void 0 ? void 0 : foundMockeryMapperFaker()) !== null && _a !== void 0 ? _a : undefined;
}
function parseString(zodRef, options) {
    var _a;
    // Prioritize user provided generators.
    if ((options === null || options === void 0 ? void 0 : options.keyName) && options.stringMap) {
        // min/max length handling is not applied here
        const generator = options.stringMap[options.keyName];
        if (generator) {
            return generator();
        }
    }
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    const { checks = [] } = zodRef._def;
    const regexCheck = checks.find((check) => check.kind === 'regex');
    if (regexCheck && 'regex' in regexCheck) {
        const generator = new randExp(regexCheck.regex);
        generator.randInt = (min, max) => fakerInstance.number.int({ min, max });
        const max = checks.find((check) => check.kind === 'max');
        if (max && 'value' in max && typeof max.value === 'number') {
            generator.max = max.value;
        }
        const genRegString = generator.gen();
        return genRegString;
    }
    const lowerCaseKeyName = (_a = options === null || options === void 0 ? void 0 : options.keyName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    const stringOptions = {};
    checks.forEach((item) => {
        switch (item.kind) {
            case 'min':
                stringOptions.min = item.value;
                break;
            case 'max':
                stringOptions.max = item.value;
                break;
            case 'length':
                stringOptions.min = item.value;
                stringOptions.max = item.value;
                break;
        }
    });
    const sortedStringOptions = Object.assign({}, stringOptions);
    // avoid Max {Max} should be greater than min {Min}
    if (sortedStringOptions.min &&
        sortedStringOptions.max &&
        sortedStringOptions.min > sortedStringOptions.max) {
        const temp = sortedStringOptions.min;
        sortedStringOptions.min = sortedStringOptions.max;
        sortedStringOptions.max = temp;
    }
    const targetStringLength = fakerInstance.number.int(sortedStringOptions);
    /**
     * Returns a random lorem word using `faker.lorem.word(length)`.
     * This method can return undefined for large word lengths. If undefined is returned
     * when specifying a large word length, will return `faker.lorem.word()` instead.
     */
    const defaultGenerator = () => targetStringLength > 10
        ? fakerInstance.lorem.word()
        : fakerInstance.lorem.word({ length: targetStringLength });
    const dateGenerator = () => fakerInstance.date.recent().toISOString().substring(0, 10);
    const datetimeGenerator = () => fakerInstance.date.recent().toISOString();
    const stringGenerators = {
        default: defaultGenerator,
        email: fakerInstance.internet.exampleEmail,
        uuid: fakerInstance.string.uuid,
        uid: fakerInstance.string.uuid,
        url: fakerInstance.internet.url,
        name: fakerInstance.person.fullName,
        date: dateGenerator,
        dateTime: datetimeGenerator,
        colorHex: fakerInstance.internet.color,
        color: fakerInstance.internet.color,
        backgroundColor: fakerInstance.internet.color,
        textShadow: fakerInstance.internet.color,
        textColor: fakerInstance.internet.color,
        textDecorationColor: fakerInstance.internet.color,
        borderColor: fakerInstance.internet.color,
        borderTopColor: fakerInstance.internet.color,
        borderRightColor: fakerInstance.internet.color,
        borderBottomColor: fakerInstance.internet.color,
        borderLeftColor: fakerInstance.internet.color,
        borderBlockStartColor: fakerInstance.internet.color,
        borderBlockEndColor: fakerInstance.internet.color,
        borderInlineStartColor: fakerInstance.internet.color,
        borderInlineEndColor: fakerInstance.internet.color,
        columnRuleColor: fakerInstance.internet.color,
        outlineColor: fakerInstance.internet.color,
        phoneNumber: fakerInstance.phone.number,
    };
    const stringType = Object.keys(stringGenerators).find((genKey) => genKey.toLowerCase() === lowerCaseKeyName ||
        checks.find((item) => item.kind.toUpperCase() === genKey.toUpperCase())) || null;
    let generator = defaultGenerator;
    if (stringType) {
        generator = stringGenerators[stringType];
    }
    else {
        const foundFaker = (options === null || options === void 0 ? void 0 : options.keyName)
            ? findMatchingFaker(options === null || options === void 0 ? void 0 : options.keyName, options.faker, options.mockeryMapper)
            : undefined;
        if (foundFaker) {
            generator = foundFaker;
        }
    }
    // it's possible for a zod schema to be defined with a
    // min that is greater than the max. While that schema
    // will never parse without producing errors, we will prioritize
    // the max value because exceeding it represents a potential security
    // vulnerability (buffer overflows).
    let val = generator().toString();
    const delta = targetStringLength - val.length;
    if (stringOptions.min != null && val.length < stringOptions.min) {
        val = val + fakerInstance.string.alpha(delta);
    }
    return val.slice(0, stringOptions.max);
}
function parseBoolean(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    // generate the mock boolean from the mockery mapper
    const mockBoolean = generateMockFromMatchingFaker(options);
    // verify that the return type of the mock data is a boolean for it to be acceptable
    if (typeof mockBoolean === 'boolean')
        return mockBoolean;
    return fakerInstance.datatype.boolean();
}
function parseDate(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    const { checks = [] } = zodRef._def;
    let min;
    let max;
    checks.forEach((item) => {
        switch (item.kind) {
            case 'min':
                min = item.value;
                break;
            case 'max':
                max = item.value;
                break;
        }
    });
    // generate the mock date from the mockery mapper
    const mockDate = generateMockFromMatchingFaker(options);
    // verify that the return type of the mock data is a valid date for it to be acceptable
    if (mockDate instanceof Date)
        return mockDate;
    if (min !== undefined && max !== undefined) {
        return fakerInstance.date.between({ from: min, to: max });
    }
    else if (min !== undefined && max === undefined) {
        return fakerInstance.date.soon({ refDate: min });
    }
    else if (min === undefined && max !== undefined) {
        return fakerInstance.date.recent({ refDate: max });
    }
    else {
        return fakerInstance.date.soon();
    }
}
function parseNumber(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    const { checks = [] } = zodRef._def;
    const fakerOptions = {};
    checks.forEach((item) => {
        switch (item.kind) {
            case 'int':
                break;
            case 'min':
                fakerOptions.min = item.value;
                break;
            case 'max':
                fakerOptions.max = item.value;
                break;
        }
    });
    // generate the mock number from the mockeryMapper
    const mockNumber = generateMockFromMatchingFaker(options);
    // verify that the return type of the mock data is a number for it to be acceptable
    if (typeof mockNumber === 'number')
        return mockNumber;
    return fakerInstance.number.int(fakerOptions);
}
function parseOptional(zodRef, options) {
    return generateMock(zodRef.unwrap(), options);
}
function parseArray(zodRef, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    let min = (_d = (_b = (_a = zodRef._def.minLength) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : (_c = zodRef._def.exactLength) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 1;
    const max = (_h = (_f = (_e = zodRef._def.maxLength) === null || _e === void 0 ? void 0 : _e.value) !== null && _f !== void 0 ? _f : (_g = zodRef._def.exactLength) === null || _g === void 0 ? void 0 : _g.value) !== null && _h !== void 0 ? _h : 5;
    // prevents arrays from exceeding the max regardless of the min.
    if (min > max) {
        min = max;
    }
    const targetLength = fakerInstance.number.int({ min, max });
    const results = [];
    for (let index = 0; index < targetLength; index++) {
        results.push(generateMock(zodRef._def.type, options));
    }
    return results;
}
function parseSet(zodRef, options) {
    var _a, _b;
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    let min = ((_a = zodRef._def.minSize) === null || _a === void 0 ? void 0 : _a.value) != null ? zodRef._def.minSize.value : 1;
    const max = ((_b = zodRef._def.maxSize) === null || _b === void 0 ? void 0 : _b.value) != null ? zodRef._def.maxSize.value : 5;
    // prevents arrays from exceeding the max regardless of the min.
    if (min > max) {
        min = max;
    }
    const targetLength = fakerInstance.number.int({ min, max });
    const results = new Set();
    while (results.size < targetLength) {
        results.add(generateMock(zodRef._def.valueType, options));
    }
    return results;
}
function parseMap(zodRef, options) {
    var _a;
    const targetLength = (_a = options === null || options === void 0 ? void 0 : options.mapEntriesLength) !== null && _a !== void 0 ? _a : 1;
    const results = new Map();
    while (results.size < targetLength) {
        results.set(generateMock(zodRef._def.keyType, options), generateMock(zodRef._def.valueType, options));
    }
    return results;
}
function parseEnum(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    const values = zodRef._def.values;
    return fakerInstance.helpers.arrayElement(values);
}
function parseDiscriminatedUnion(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    // Map the options to various possible union cases
    const potentialCases = [...zodRef._def.options.values()];
    const mocked = fakerInstance.helpers.arrayElement(potentialCases);
    return generateMock(mocked, options);
}
function parseNativeEnum(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    const values = zod_1.util.getValidEnumValues(zodRef.enum);
    return fakerInstance.helpers.arrayElement(values);
}
function parseLiteral(zodRef) {
    return zodRef._def.value;
}
function parseTransform(zodRef, options) {
    const input = generateMock(zodRef._def.schema, options);
    const effect = zodRef._def.effect.type === 'transform'
        ? zodRef._def.effect
        : { transform: () => input };
    return effect.transform(input, { addIssue: () => undefined, path: [] }); // TODO : Discover if context is necessary here
}
function parseUnion(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    // Map the options to various possible mock values
    const potentialCases = [...zodRef._def.options.values()];
    const mocked = fakerInstance.helpers.arrayElement(potentialCases);
    return generateMock(mocked, options);
}
function parseZodIntersection(zodRef, options) {
    const left = generateMock(zodRef._def.left, options);
    const right = generateMock(zodRef._def.right, options);
    return Object.assign(left, right);
}
function parseZodTuple(zodRef, options) {
    const results = [];
    zodRef._def.items.forEach((def) => {
        results.push(generateMock(def, options));
    });
    if (zodRef._def.rest !== null) {
        const next = parseArray(zod_1.z.array(zodRef._def.rest), options);
        results.push(...(next !== null && next !== void 0 ? next : []));
    }
    return results;
}
function parseZodFunction(zodRef, options) {
    return function zodMockFunction() {
        return generateMock(zodRef._def.returns, options);
    };
}
function parseZodDefault(zodRef, options) {
    const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
    // Use the default value 50% of the time
    if (fakerInstance.datatype.boolean()) {
        return zodRef._def.defaultValue();
    }
    else {
        return generateMock(zodRef._def.innerType, options);
    }
}
function parseZodPromise(zodRef, options) {
    return Promise.resolve(generateMock(zodRef._def.type, options));
}
function parseBranded(zodRef, options) {
    return generateMock(zodRef.unwrap(), options);
}
function parseLazy(zodRef, options) {
    return generateMock(zodRef._def.getter(), options);
}
function parseReadonly(zodRef, options) {
    return generateMock(zodRef._def.innerType, options);
}
const workerMap = {
    ZodObject: parseObject,
    ZodRecord: parseRecord,
    ZodString: parseString,
    ZodNumber: parseNumber,
    ZodBigInt: parseNumber,
    ZodBoolean: parseBoolean,
    ZodDate: parseDate,
    ZodOptional: parseOptional,
    ZodNullable: parseOptional,
    ZodArray: parseArray,
    ZodEnum: parseEnum,
    ZodNativeEnum: parseNativeEnum,
    ZodLiteral: parseLiteral,
    ZodTransformer: parseTransform,
    ZodEffects: parseTransform,
    ZodUnion: parseUnion,
    ZodSet: parseSet,
    ZodMap: parseMap,
    ZodDiscriminatedUnion: parseDiscriminatedUnion,
    ZodIntersection: parseZodIntersection,
    ZodTuple: parseZodTuple,
    ZodFunction: parseZodFunction,
    ZodDefault: parseZodDefault,
    ZodPromise: parseZodPromise,
    ZodLazy: parseLazy,
    ZodBranded: parseBranded,
    ZodNull: () => null,
    ZodNaN: () => NaN,
    ZodReadonly: parseReadonly,
};
function generateMock(zodRef, options) {
    try {
        const fakerInstance = (options === null || options === void 0 ? void 0 : options.faker) || faker_1.faker;
        if (options === null || options === void 0 ? void 0 : options.seed) {
            fakerInstance.seed(Array.isArray(options.seed) ? options.seed : [options.seed]);
        }
        const typeName = zodRef._def.typeName;
        if (typeName in workerMap) {
            return workerMap[typeName](zodRef, options);
        }
        else if ((options === null || options === void 0 ? void 0 : options.backupMocks) && typeName in options.backupMocks) {
            // check for a generator match in the options.
            // workaround for unimplemented Zod types
            const generator = options.backupMocks[typeName];
            if (generator) {
                return generator(zodRef, options);
            }
        }
        else if (options === null || options === void 0 ? void 0 : options.throwOnUnknownType) {
            throw new ZodMockError(typeName);
        }
        return undefined;
    }
    catch (err) {
        if (err instanceof ZodMockError) {
            throw err;
        }
        console.error(err);
        return undefined;
    }
}
exports.generateMock = generateMock;
class ZodMockError extends Error {
    constructor(typeName) {
        super(`Unable to generate a mock value for ZodType ${typeName}.`);
        this.typeName = typeName;
    }
}
exports.ZodMockError = ZodMockError;
//# sourceMappingURL=zod-mock.js.map