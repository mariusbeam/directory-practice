import { h, getColorClassName, objAssign, getFootnoteRefId, getFootnoteContentId, } from '../utils.js';
const getHastsWithBr = (text) => {
    const hasBreak = text.includes('\n');
    if (!hasBreak) {
        return [h('text', text)];
    }
    const textParts = text.split('\n');
    const textPartsCount = textParts.length;
    const result = [];
    for (let i = 0; i < textPartsCount; i += 1) {
        const isLastPart = i === textPartsCount - 1;
        result.push(h('text', textParts[i]));
        !isLastPart && result.push(h('br', []));
    }
    return result;
};
const annotationKeysInWrapperOrder = ['code', 'bold', 'italic', 'strikethrough', 'underline'];
const tagsByAnnotationKey = {
    code: 'code',
    bold: 'b',
    italic: 'i',
    strikethrough: 's',
    underline: 'u',
};
const handler = (context, block, richTextObj, turnLineBreakToBr = true) => {
    const { type, plain_text, href, annotations } = richTextObj;
    const rawHtml = context.options.convertRawHtml?.(richTextObj);
    if (typeof rawHtml === 'string') {
        return h('raw', rawHtml);
    }
    let footnoteRefs;
    const isFootnoteSign = annotations.code &&
        plain_text === '[^]' &&
        (footnoteRefs = block && context.options.footnoteReference?.[block.id]) &&
        footnoteRefs.length > 0;
    if (isFootnoteSign) {
        const footnodeCount = context.addFootnote(footnoteRefs.shift());
        const id = getFootnoteRefId(footnodeCount);
        const contentId = getFootnoteContentId(footnodeCount);
        return h('sup', { className: ['footnote-ref'] }, [
            h('a', { id, href: `#${contentId}` }, [h('text', String(footnodeCount))]),
        ]);
    }
    let hasts = turnLineBreakToBr
        ? getHastsWithBr(plain_text)
        : [h('text', plain_text)];
    if (turnLineBreakToBr && plain_text.includes('\n')) {
    }
    annotationKeysInWrapperOrder.forEach((key) => {
        if (annotations[key]) {
            const wrapperTag = tagsByAnnotationKey[key];
            hasts = [h(wrapperTag, hasts)];
        }
    });
    if (href) {
        hasts = [h('a', { href }, hasts)];
    }
    if (hasts.length > 1) {
        hasts = [h('span', hasts)];
    }
    let hast = hasts[0];
    const mathClassName = type === 'equation' ? ['math', 'math-inline'] : [];
    const colorClassName = getColorClassName(annotations.color);
    const className = [...mathClassName, colorClassName].filter(Boolean);
    if (className.length > 0) {
        if (hast.type === 'text') {
            hast = h('span', [hast]);
        }
        hast.properties = objAssign(hast.properties, { className });
    }
    // TODO: Mention blocks
    return hast;
};
export const addTasksToAddRichTexts = ({ context, block, hast, richTexts, wrapRichTexts, turnLineBreakToBr, }) => {
    let hastForRichTexts = hast;
    if (wrapRichTexts) {
        const wrapper = h('p', []);
        context.addTasks(() => hast.children.push(wrapper));
        hastForRichTexts = wrapper;
    }
    context.addTasks(richTexts, (richTextObj) => (ctx) => {
        hastForRichTexts.children.push(handler(ctx, block, richTextObj, turnLineBreakToBr));
    });
};
export default handler;
