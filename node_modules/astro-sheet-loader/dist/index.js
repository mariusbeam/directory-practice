// src/sheet-loader.ts
import { AstroError } from "astro/errors";
import { z } from "astro/zod";
async function sheetToJSON({ url }) {
  const response = await fetchJSON(url);
  const text = await response.text();
  return parseJSON(text, url);
}
async function fetchJSON(url) {
  return fetch(url).catch((error) => {
    throw new AstroError(`Error fetching ${url}: ${error}`);
  });
}
async function parseJSON(text, url) {
  if (text.startsWith("<!DOCTYPE html>")) {
    throw new AstroError(
      `Error fetching JSON data for '${url}', check the ID and share settings of the document.`
    );
  }
  let jsonObject;
  const jsonString = text.slice(47, -2);
  try {
    jsonObject = JSON.parse(jsonString);
  } catch (error) {
    throw new AstroError(`Error parsing JSON data for '${url}': ${error}`);
  }
  if (jsonObject.status === "error") {
    throw new AstroError(
      `Error in JSON data for '${url}': ${jsonObject.errors?.[0]?.detailed_message ?? "Unknown error"}`
    );
  }
  return jsonObject;
}
var camelCase = (text) => {
  return `${text}`.toLowerCase().replace(/[-_]+/g, " ").replace(/[^\w\s]/g, "").replace(/ (.)/g, ($1) => $1.toUpperCase()).replace(/ /g, "");
};
var snake_case = (text) => {
  return `${text}`.charAt(0).toLowerCase() + `${text}`.slice(1).replace(/\W+/g, " ").replace(/([a-z])([A-Z])([a-z])/g, "$1 $2$3").split(/\B(?=[A-Z]{2,})/).join(" ").split(" ").join("_").toLowerCase();
};
var SHEET_ZOD_TYPE_MAP = /* @__PURE__ */ new Map([
  ["boolean", z.boolean()],
  ["number", z.number()],
  ["string", z.string()],
  // google is not returning ISO 8601 UTC dates, so we avoid validating them
  ["date", z.string()],
  ["datetime", z.string()]
]);
async function sheetSchemaToZodSchema({
  cols,
  transformHeader = false,
  allowBlanks = false
}) {
  const schemaObject = {};
  for (const column of cols) {
    const zodType = SHEET_ZOD_TYPE_MAP.get(column.type) ?? z.string();
    const columnName = transformHeader ? transformHeader(column.label) : `${column.label}`;
    schemaObject[columnName] = allowBlanks ? zodType.nullable().optional() : zodType;
  }
  const zodSchema = z.object(schemaObject);
  return zodSchema;
}
function processHeader({
  cols,
  transformHeader,
  collection,
  logger
}) {
  const columns = [];
  for (const column of cols) {
    const columnName = transformHeader ? transformHeader(column.label) : `${column.label}`;
    columns.push(columnName);
  }
  if (columns.every((column) => column.trim() === "")) {
    logger.error(
      `${collection}: Blank column names: | ${columns.join(" | ")} |`
    );
    throw new AstroError("Error retrieving column names.");
  }
  return columns;
}
async function processContent({
  rows,
  columns,
  collection,
  logger,
  store,
  generateDigest,
  parseData
}) {
  if (rows.length === 0) {
    logger.warn(`${collection}: No entry was loaded.`);
  } else {
    let rowID = 0;
    for (const row of rows) {
      logger.debug(`${collection}: Processing row ${rowID}`);
      const id = `row_${rowID}`;
      const rowData = {};
      row.c.forEach((c, index) => {
        const columnName = columns[index];
        if (!columnName) return;
        rowData[columnName] = valueOrFormat(c);
      });
      const parsedData = await parseData({ id, data: rowData }).catch(
        (error) => {
          logger.error(
            `${collection}: Error validating row ${rowID} (${JSON.stringify(row)}): ${error.message}`
          );
          throw new AstroError("Error validating row data.");
        }
      );
      const digest = generateDigest(parsedData);
      logger.debug(`        Source data: ${rowData}`);
      logger.debug(`        Parsed data: ${parsedData}`);
      store.set({ id, data: parsedData, digest });
      rowID++;
    }
    logger.info(
      `${collection}: Loaded ${rows.length} entries with these ${columns.length} fields: | ${columns.join(" | ")} |`
    );
  }
}
function valueOrFormat(c) {
  const regexISODate = /^\d{4}-\d{2}-\d{2}$/;
  const regexFunDate = /^Date\(.*\)$/;
  if (!c) {
    return void 0;
  }
  if (c.v === null) {
    return void 0;
  }
  if (!c.f) {
    return c.v;
  }
  if (Number.isInteger(c.v) && regexISODate.test(c.f)) {
    return c.f;
  }
  if (regexFunDate.test(`${c.v}`)) {
    return c.f;
  }
  return c.v;
}
function sheetLoader({
  document,
  gid = 0,
  sheet = void 0,
  range = void 0,
  query = void 0,
  transformHeader = false,
  allowBlanks = false
}) {
  const sheetParam = `&${sheet ? `sheet=${sheet}` : `gid=${gid}`}`;
  const rangeParam = range ? `&range=${range}` : "";
  const queryParam = query ? `&tq=${encodeURIComponent(query)}` : "";
  const url = `https://docs.google.com/spreadsheets/d/${document}/gviz/tq?tqx=out:json${sheetParam}${rangeParam}${queryParam}`;
  let cachedJson = null;
  let autoSchema = false;
  return {
    name: "sheet-loader",
    load: async ({
      logger,
      parseData,
      generateDigest,
      store,
      collection
    }) => {
      if (!cachedJson) {
        cachedJson = await sheetToJSON({ url });
      }
      const json = cachedJson;
      logger.info(
        `${collection}: Loading ${url.replace(/tqx=out:json/, "tqx=out:html")}`
      );
      const columns = processHeader({
        cols: json.table.cols,
        transformHeader,
        collection,
        logger
      });
      return processContent({
        rows: json.table.rows,
        columns,
        collection,
        logger,
        store,
        generateDigest,
        parseData
      });
    },
    schema: async () => {
      if (!cachedJson) {
        cachedJson = await sheetToJSON({ url });
      }
      const json = cachedJson;
      autoSchema = true;
      return sheetSchemaToZodSchema({
        cols: json.table.cols,
        transformHeader,
        allowBlanks
      });
    }
  };
}
export {
  camelCase,
  sheetLoader,
  sheetSchemaToZodSchema,
  sheetToJSON,
  snake_case
};
//# sourceMappingURL=index.js.map